// parser:

expression9:
 ( <expression> )  should be: expression 1, forall ignored otherwise

order of the parsed items in pLhs is different from the thesis docs


while loop break's are, in the control flow graph, linked to the 'assume !guard' statement after the while loop.
This is problematic since we cannot assume this when a break occurs, feasible paths will be marked infeasible because the assumption is false.
I fixed this currently by adding a ite(!guard, skip, skip) statement in the parser, which is called after the while loop.
This ensures that we check whether the while loop has exited through !guard condition or a break statement.

    ^ nvm, sort function fails after doing this.

// cfg:
 fallthrough missing for ite en seq

 execRhsField is niet consistent met doc (thesis versie die ik heb)




Original OOX deals with symbolic references in Z3 expressions as follows:
Find all concrete references (aliasMap) for each of the symbolic references 
create for each combination of these an expression with their concrete references
this results in multiple expressions that need to be solved


_node = [null, ref(1)] 
_next1 = [null, ref(1), ref(2)]


_node + _next1
becomes len(_node) * len(_next1) z3 invocations

null + null
null + ref(1)
null + ref(2)
ref(1) + null
ref(1) + ref(1)
ref(1) + ref(2)



Something weird is going on with null, why add it to only then immediately remove it?

Ok dus we halen null weg bij execLhs en execRhs want deze zijn al covered door de exception handling, behalve bij de concretization, 
als een symbolic ref daar initialised wordt dan kan het wel null zijn.

Vergeten om if !null checks te doen op rhsmethodcall?





[14:49:55] Verifying: '!(!(_node != null) && _next1 == null && !(_node == null) && !(_value1 == _value1) && _node != null && true ==> false)'
[14:49:55] Evaluating '!(!(_node != null) && _next1 == null && !(_node == null) && !(_value1 == _value1) && _node != null && true ==> false)' as a bool
[14:49:55] Initializing symbolic reference '_next1:Node' to '{null,ref(1),ref(2)}
[14:49:55] Evaluating '!(!(!(null != null) && null == null && !(null == null) && !(_value1 == _value1) && null != null))' as a bool
[14:49:55] Evaluating '!(!(!(ref(1) != null) && null == null && !(ref(1) == null) && !(_value1 == _value1) && ref(1) != null))' as a bool
[14:49:55] Evaluating '!(!(!(null != null) && ref(1) == null && !(null == null) && !(_value1 == _value1) && null != null))' as a bool
[14:49:55] Evaluating '!(!(!(ref(1) != null) && ref(1) == null && !(ref(1) == null) && !(_value1 == _value1) && ref(1) != null))' as a bool
[14:49:55] Evaluating '!(!(!(null != null) && ref(2) == null && !(null == null) && !(_value1 == _value1) && null != null))' as a bool
[14:49:55] Evaluating '!(!(!(ref(1) != null) && ref(2) == null && !(ref(1) == null) && !(_value1 == _value1) && ref(1) != null))' as a bool

Might it be better to keep _node and _next1 as variables in Z3? idk
as the number of symbolic references increases... this explodes!

vgm zorgt alias map voor heel veel infeasible values, snel
_node kan niet null zijn als next1 bestaat want dat zou betekenen dat next1 nooit aangemaakt wordt,
eigenlijk moet null uit de alias map gehaald worden voor die branch?

hetzelfde geldt voor wanneer je een linked list hebt met 3 nodes,
{_node, _next1, _next2}
de aliasMap van next1 mag geen null of _node bevatten als het op een punt is gekomen dat _next2 is gegenereerd toch?
dat is een nadeel aan lazy initialisation, je genereerd het object pas echt als 




// arrays

For arrays we use state splitting, each path has its own array (as a concrete reference) with a unique size. (increasingly larger)
Unlike objects, we don't use the alias map for arrays. 

Currently only support 1D arrays, old OOX supports multiple dimensional arrays.



// exceptions
in thesis, the exceptions(rhs_elem(i, E)) =