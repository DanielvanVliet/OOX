class Point {
    int x ;
    int y ;
    Point(int x, int y) {
       this.x := x ;
       this.y := y ;
    }

    // operator `<=`
    bool lessThanOnX(Point other) {
        int thisX := this.x;
        int otherX := other.x;
        return thisX <= otherX;
    }
}


interface Sorter {
    Point[] sort(Point[] array);
}

class BubbleSort implements Sorter {
    BubbleSort() {}

    Point[] sort(Point[] array)
        requires(array != null)
        ensures(true)
        exceptional(false)
    {
        bool sorted := false;
        while (!sorted) {
            sorted := true;
            int i := 1;
            while (i < #array) {
                Point u := array[i];
                Point v := array[i - 1];
                assume u != null ;
                assume v != null ;
                int a := u.x ;
                int b := v.x ;
                if (a < b) {
                    array[i] := v;
                    array[i - 1] := u;
                    sorted := false;
                }
                i := i + 1;
            }
        }
        return array;
    }
}



class MergeSort implements Sorter {
    MergeSort() {}
    Point[] sort(Point[] array)
        requires(!(array == null))
        exceptional(false)
    {
        MergeSort.mergesort(array, 0, #array - 1);
        return array;
    }

    static void mergesort(Point[] array, int left, int right)
        requires(array != null)
        exceptional(false)
    {
        // if (left >= right) {  // error , should be <
        if (left < right) {
            int middle := (left + right) / 2;
            MergeSort.mergesort(array, left, middle);
            MergeSort.mergesort(array, middle + 1, right);
            MergeSort.merge(array, left, middle, right);
        }
    }

    static void merge(Point[] array, int left, int middle, int right)
        requires(array != null)
        exceptional(false)
    {
        Point[] temp := new Point[right - left + 1];
        int i := left;
        int j := middle + 1;
        int k := 0;
        while (i <= middle && j <= right) {
            Point arrayI := array[i];
            assume arrayI != null;
            Point arrayJ := array[j];
            assume arrayJ != null;
            bool arrayILessThanArrayJ := arrayI.lessThanOnX(arrayJ);
            if (arrayILessThanArrayJ) {
                temp[k] := array[i];
                k := k + 1;
                i := i + 1;
            } else {
                temp[k] := array[j];
                k := k + 1;
                j := j + 1;
            }
        }
        while (i <= middle) {
            temp[k] := array[i];
            k := k + 1;
            i := i + 1;
        }

        while (j <= right) {
            temp[k] := array[j];
            k := k + 1;
            j := j + 1;
        }
        i := left;
        while (i <= right) {
            array[i] := temp[i - left];
            i := i + 1;
        }
    }
}

class Main
{
    static void test(Point[] array, MergeSort sorter)
        requires(array != null)
    {
        int N := 5;
        array := sorter.sort(array);


        // assert it is sorted on x
        int[] xs := new int[N];
        int ix := 0;
        while (ix < #array) {
            Point arrayI := array[ix];
            xs[ix] := arrayI.x;
            ix := ix + 1;
        }
        assert forall v , i : xs : (forall w , j : xs : i < j && j < #array ==> v <= w);
    }
}
